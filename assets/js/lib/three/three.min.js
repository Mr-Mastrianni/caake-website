/**
 * Simplified Three.js for CAAKE website
 * This is a minimal version of Three.js that only includes what we need for the logo animation
 */

// Create THREE namespace if it doesn't exist
window.THREE = window.THREE || {};

// Basic Three.js classes
THREE.Vector2 = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
};

THREE.Vector3 = function(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
};

THREE.Color = function(color) {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    
    if (typeof color === 'number') {
        this.setHex(color);
    }
    
    return this;
};

THREE.Color.prototype.setHex = function(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
};

// Clock for animations
THREE.Clock = function(autoStart) {
    this.autoStart = (autoStart !== undefined) ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
};

THREE.Clock.prototype.start = function() {
    this.startTime = Date.now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
};

THREE.Clock.prototype.getDelta = function() {
    let diff = 0;
    if (this.autoStart && !this.running) {
        this.start();
        return 0;
    }
    if (this.running) {
        const newTime = Date.now();
        diff = (newTime - this.oldTime) / 1000;
        this.oldTime = newTime;
        this.elapsedTime += diff;
    }
    return diff;
};

// Basic scene setup
THREE.Scene = function() {
    this.children = [];
    this.background = null;
};

THREE.Scene.prototype.add = function(object) {
    this.children.push(object);
};

THREE.Scene.prototype.remove = function(object) {
    const index = this.children.indexOf(object);
    if (index !== -1) {
        this.children.splice(index, 1);
    }
};

// Camera
THREE.PerspectiveCamera = function(fov, aspect, near, far) {
    this.fov = fov || 50;
    this.aspect = aspect || 1;
    this.near = near || 0.1;
    this.far = far || 2000;
    this.position = new THREE.Vector3();
    this.rotation = new THREE.Vector3();
};

THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
    // In a real implementation, this would update the projection matrix
};

// Renderer
THREE.WebGLRenderer = function(parameters) {
    parameters = parameters || {};
    
    this.domElement = document.createElement('canvas');
    this.domElement.style.width = '100%';
    this.domElement.style.height = '100%';
    
    this.setSize = function(width, height) {
        this.domElement.width = width;
        this.domElement.height = height;
    };
    
    this.setPixelRatio = function(value) {
        // In a real implementation, this would set the pixel ratio
    };
    
    this.render = function(scene, camera) {
        // In a real implementation, this would render the scene
        // For our purposes, we'll just draw a placeholder
        const ctx = this.domElement.getContext('2d');
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, this.domElement.width, this.domElement.height);
        
        // Draw a simple CAAKE text
        ctx.font = 'bold 48px Arial';
        ctx.fillStyle = '#5773ff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('CAAKE', this.domElement.width / 2, this.domElement.height / 2);
    };
};

// Basic materials
THREE.MeshStandardMaterial = function(parameters) {
    this.color = new THREE.Color(0xffffff);
    this.emissive = new THREE.Color(0x000000);
    this.metalness = 0.5;
    this.roughness = 0.5;
    
    if (parameters) {
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.emissive !== undefined) this.emissive = new THREE.Color(parameters.emissive);
        if (parameters.metalness !== undefined) this.metalness = parameters.metalness;
        if (parameters.roughness !== undefined) this.roughness = parameters.roughness;
    }
};

// Lights
THREE.AmbientLight = function(color, intensity) {
    this.color = new THREE.Color(color);
    this.intensity = intensity !== undefined ? intensity : 1;
};

THREE.DirectionalLight = function(color, intensity) {
    this.color = new THREE.Color(color);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.position = new THREE.Vector3(0, 1, 0);
};

THREE.PointLight = function(color, intensity, distance) {
    this.color = new THREE.Color(color);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.distance = distance !== undefined ? distance : 0;
    this.position = new THREE.Vector3(0, 0, 0);
};

// Post-processing (simplified)
THREE.EffectComposer = function(renderer) {
    this.renderer = renderer;
    this.passes = [];
    
    this.addPass = function(pass) {
        this.passes.push(pass);
    };
    
    this.setSize = function(width, height) {
        // In a real implementation, this would resize all passes
    };
    
    this.render = function() {
        // In a real implementation, this would render all passes
        // For our purposes, we'll just call the renderer's render method
        if (this.renderer && this.renderer.render) {
            this.renderer.render();
        }
    };
};

THREE.RenderPass = function(scene, camera) {
    this.scene = scene;
    this.camera = camera;
};

THREE.UnrealBloomPass = function(resolution, strength, radius, threshold) {
    this.resolution = resolution;
    this.strength = strength;
    this.radius = radius;
    this.threshold = threshold;
};

// FontLoader and TextGeometry (simplified)
THREE.FontLoader = function() {
    this.load = function(url, onLoad) {
        // Simulate loading a font
        setTimeout(function() {
            const font = {
                generateShapes: function() {
                    return [];
                }
            };
            if (onLoad) onLoad(font);
        }, 100);
    };
};

THREE.TextGeometry = function(text, parameters) {
    this.parameters = parameters;
    this.text = text;
    
    this.center = function() {
        // In a real implementation, this would center the geometry
    };
};

// Particle system
THREE.BufferGeometry = function() {
    this.attributes = {};
    
    this.setAttribute = function(name, attribute) {
        this.attributes[name] = attribute;
    };
};

THREE.Float32BufferAttribute = function(array, itemSize) {
    this.array = array;
    this.itemSize = itemSize;
    this.needsUpdate = false;
};

THREE.Points = function(geometry, material) {
    this.geometry = geometry;
    this.material = material;
    this.position = new THREE.Vector3();
    this.rotation = new THREE.Vector3();
};

THREE.PointsMaterial = function(parameters) {
    this.color = new THREE.Color(0xffffff);
    this.size = 1;
    
    if (parameters) {
        if (parameters.color !== undefined) this.color = new THREE.Color(parameters.color);
        if (parameters.size !== undefined) this.size = parameters.size;
    }
};

// Mesh
THREE.Mesh = function(geometry, material) {
    this.geometry = geometry;
    this.material = material;
    this.position = new THREE.Vector3();
    this.rotation = new THREE.Vector3();
    this.scale = new THREE.Vector3(1, 1, 1);
};

console.log('Simplified Three.js loaded for CAAKE website');
